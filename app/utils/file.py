# The Code is to implement hash generation and file saving
# -*- coding: utf-8 -*-
# Author: Shibo Li
# Date: 2025-05-13

import hashlib
import uuid
from pathlib import Path
from typing import List, Optional

from app.core.config import TMP_DIR, CACHE_DIR


def save_uploaded_file(uploaded_file, prefix: str = "task") -> Path:
    """
    Upload Files to temporary directory and return the file path

    Args:
        uploaded_file: UploadFile 
        prefix (str): optional, prefix for the task ID

    Returns:
        Path: path to the saved file
    """
    TMP_DIR.mkdir(parents=True, exist_ok=True)
    task_id = f"{prefix}_{uuid.uuid4().hex}"
    task_dir = TMP_DIR / task_id
    task_dir.mkdir(parents=True)

    file_path = task_dir / uploaded_file.filename
    with open(file_path, "wb") as f:
        f.write(uploaded_file.file.read())

    return file_path


def compute_cache_key(file_path: Path, args: List[str], extra: Optional[str] = None) -> str:
    """
    generate a cache key based on the file content and command arguments
    This key is used to check if the result is already cached.

    Args:
        file_path (Path): path to the input file
        args (List[str]): parameters passed to the command of zeo++
        extra (str): optional, extra identifier to distinguish different calls

    Returns:
        str: sha256 hash of the file content and command arguments
    """
    file_bytes = file_path.read_bytes()
    m = hashlib.sha256()
    m.update(file_bytes)
    m.update(" ".join(args).encode())
    if extra:
        m.update(extra.encode())
    return m.hexdigest()


def get_cache_path(cache_key: str) -> Path:
    """
    Return the cache path based on the cache key

    Args:
        cache_key (str): cache key generated by compute_cache_key
    Returns:
        Path: workspace/cache/<hash> path
    """
    return CACHE_DIR / cache_key
